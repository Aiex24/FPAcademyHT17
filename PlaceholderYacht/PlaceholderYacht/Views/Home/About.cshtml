@section styles{
    <link href="~/Styles/AboutStyleSheet.css" rel="stylesheet" />
}
    <img class="aboutimg" src="~/Images/About.png" />

<div id="infoTextAbout">
    <h2>1. Background</h2>
    <p>Academy is a part of the consulting company Academic Work with a concept to fulfil the competence needs of the market, using a concept of accelerated learning. One of those programs teaches programming with the object-oriented language C# on the .NET Framework during a 12-week time span, with the goal that the participants will become IT-consultants [1]. The course bla bla bla and ends with a 2 week final project. And blab la bla this is the result something something</p>

    <h2>2. Purpose</h2>
    <p>The purpose of the final project is to link together the techniques and subjects that the participants have been in touch with, in an aspect of Personal Development. Furthermore … apply those techniques and skills obtained during the course together within a project [2].</p>
    <h2>3. Goal</h2>
    <p>The final project of Academy accelerated learning in C# HT17 was created between the fourth and fifteenth of December 2017, during the last two weeks of the course. The goal with WindCatchaz is to create a project dedicated to presenting the speeds and routes of sailboats by retrieving weather data from an external source like SMHI [3] and calculate how long this trip will take based on defined values from a VPP, Velocity Prediction Program, compared to the relative direction of the sailboat.</p>

    <span><b>Project name: </b>WindCatchers</span><br />
    <span><b>Development team: </b>Robin Lundqvist, Mattias Lij, Tobias Rondin, Mikael Angelstam, Alexander Krasse</span><br />
    <span><b>Framework: </b>ASP.NET Core 2.0</span><br />
    <span><b>Language: </b>C#, JavaScript, SQL, HTML, CSS</span><br />
    <span><b>Methodologies: </b>Scrum</span><br />
    <span><b>Architectural pattern: </b>Model-View-Controller</span>

    <h3>3.1 Minimum Viable Product</h3>
    <ul>
        <li>Create a map and load weather data (and show wind directions)</li>
        <li>Let the user choose a starting point and a destination point (and a departure time) and store coordinates for latitude and longitude </li>
        <li>Calculate the distance</li>
        <li>At least 1 VPP diagram retrieved from a database (this is data that is supposed to come from the ship manufacturer)</li>
        <li>Use some simple interpolation to calculate the velocity for those wind speeds that aren’t in the VPP</li>
        <li>Calculate the time it will take to go from the starting point to the goal (the program should add time for tacking if the direction is in e.g. 45° angle towards the wind, and compensate for changes in wind direction if the time frame has passed (depending on what data is given from the API)</li>
        <li>Let the user create an account and be able to store their routes</li>
    </ul>

    <h3>3.2 Suggestion of extra features</h3>
    <ul>
        <li>Make the page suitable for several browsers/platforms</li>
        <li>Let the user create their own VPP and edit those based on experience</li>
        <li>Draw the polar diagram</li>
        <li>Option to show the VPP in a cartesian diagram instead of a polar diagram</li>
        <li>Let the user only decide a few values in the VPP and use interpolation to fill in the gaps</li>
        <li>Let the user decide what interpolation method to be used</li>
        <li>404 page</li>
        <li>Suggest a better route that is faster than a straight line from A to B with some optimizing algorithm</li>
        <li>About view page with information of the project</li>
        <li>Store login information in a cookie</li>
        <li>More details of the data retrieved from the API. min max, date valid, time to update</li>
    </ul>
    <h2>4. Method</h2>
    <h3>4.1 Framework</h3>
    <h3>4.2 Language</h3>
    <h3>4.3 Methodologies</h3>
    <h3>4.4 Architectural pattern</h3>
    <h3>4.5 API</h3>
    <h3>4.6 Scripts</h3>
    <h2>5. Result</h2>
    <h3>5.1 Calculating the route</h3>

    <p>Step 1. Find the latitude for the midway point between the starting point and destination point by using the spherical version of the inverse geodesic problem</p>
    <figure>
        <img id="midpoint" src="~/Images/Midpoint.png" alt="Mid way point" style="width:20%">
        <figcaption>Figure.1 - The great circle path between a node and an arbitrary point (φ,λ) [4].</figcaption>
    </figure>
    <br />
    <p>Step 2: Calculate the geocentric radius R(&straightphi;) as a function of the geodetic latitude &straightphi; where R is the distance from the Earth's center to a point on the spheroid surface at geodetic latitude &straightphi;, for the latitude at the midway point between the starting point and the destination point</p>
    <p>
        \begin{align}
        \\R(\phi)=\sqrt{\frac{(a^2\cos{\phi})^2+(b^2\sin{\phi})^2}{(a\cos{\phi})^2+(b\sin{\phi})^2}}
        \end{align}
    </p>
    <p>where <i>a</i> is the equatorial radius and <i>b</i> is the polar radius.</p>
    <figure>
        <img id="midpoint" src="~/Images/AverageRadius.bmp" alt="Mid way point">
        <figcaption>Figure.2 - C# code to calculate the radius at the midway point.</figcaption>
    </figure>

    <p>Step 3: Calculate the orthodromic distance between the starting point and the destination point by using the haversine equation</p>
    <p>
        \begin{align}
        \\hav(\theta)=\sin^2\biggl(\frac{\theta}{2}\biggr)
        \end{align}
    </p>
    <p>where hav is the haversine function and &theta;/2 is the orthodromic distance <i>d</i> devided with the earth radius <i>R</i>  which is approximated by using radius for the midway point as a constant for the entire distance. We can now calculate the distance between the starting point and the destination point by using</p>
    <p>
        \begin{align}
        \\d = 2R\arcsin\Biggl(\sqrt{\sin^2\biggl(\frac{\phi_2-\phi_1}{2}\biggr)+\cos(\phi_2)\cos(\phi_2)\sin^2\biggl(\frac{\lambda_2-\lambda_1}{2}\biggr)}\Biggr)
        \end{align}
    </p>
    <p>Since sin<sup>-1</sup> is only defined in the range -1 to 1 alternatively the <span style="color:darkturquoise">Math</span>.Atan2(y,x) can be used which take two doubles and returns an angle in the Cartesian plane formed by the x-axis and a vector starting from the origin (0,0), and terminating at the point (x,y)  </p>

    <p>Step 4: When the distance is calculated for the entire route, the coordinates for a point on the orthodromic can be calculated as a fraction of the total distance with help from the angular distance &delta; = d / R&straightphi;. </p>

    <p>Step 5: Calculate the bearing. This can be done either by calculating the loxodrome which means the compass will show the same degree for the entire route</p>
    <figure>
        <img id="midpoint" src="~/Images/Loxodrome.png" alt="Mid way point" style="width:20%">
        <figcaption>Figure.3 - Loxodrome with the same angle for the entire route [4].</figcaption>
    </figure>
    <p>The issue with using the loxodrome is that it does not choose the shortest orthodromic distance instead the program calculates the intital angle for the orthodromic that has the shortest distance towards the goal, and approximates the calculations using this same angle for the resolution choosen.</p>
    <p>Instead the inital angle that represent the shortest orthodromic is used as the direction for the entire fraction. This angle (bearing) is used to compare what relative angle towards the wind the yacht has. This value is collected from an API e.g. SMHI. When the relative angle is known the velocity for the yacht is retrieved from the database with predefined Velocity Prediction Program diagrams by interpolation to find an approximated value that fit the actual windspeed. Now when the velocity and the length is known the time it took to travel this journey section can be calculated which gives T<sub>i</sub>. By repeating this as long as the sum of all fractions do not exceed the total length and then add a calculation for the remaining section to calculate T<sub>rest</sub>, the total amount of time to travel distance <i>d</i> is calculated with T = &Sigma;(T<sub>i</sub>)+T<sub>rest</sub></p>


    <h2>Thanks</h2>
    <h2>References</h2>
    https://en.wikipedia.org/wiki/Great-circle_navigation
    <h2>Appendix</h2>
</div>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
    tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
    });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>